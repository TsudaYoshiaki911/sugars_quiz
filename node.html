<!DOCTYPE html>
<html lang="ja">
<meta charset="utf-8">
<title>15:23簡易ノード接続</title>
<style>
  body { background:#eef2ff; font-family:sans-serif; }
  .node {
    position:absolute; background:#fff; padding:10px; border-radius:8px;
    box-shadow:0 2px 6px rgba(0,0,0,0.1); text-align:center;
  }
  .port {
    width:12px; height:12px; border-radius:50%;
    display:inline-block; margin:4px; cursor:pointer;
  }
  .in { background:#ff9f1c; }
  .out { background:#06b6d4; }
  svg { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; }
</style>
<body>
<svg id="svg"></svg>

<div class="node" id="num1" style="left:40px;top:40px;">
  <input type="number" id="val1" value="2" step="any"><br>
  <div class="port out" data-port="out"></div>
</div>

<div class="node" id="num2" style="left:40px;top:160px;">
  <input type="number" id="val2" value="3" step="any"><br>
  <div class="port out" data-port="out"></div>
</div>

<div class="node" id="func" style="left:240px;top:100px;">
  <div class="port in" data-port="a"></div>
  <select id="op">
    <option value="+">+</option>
    <option value="-">−</option>
    <option value="*">×</option>
    <option value="/">÷</option>
  </select>
  <div class="port in" data-port="b"></div>
  <br>
  <div class="port out" data-port="out"></div>
</div>

<div class="node" id="out" style="left:440px;top:120px;">
  <div class="port in" data-port="in"></div>
  <div>結果：<span id="result">?</span></div>
</div>

<script>
const svg = document.getElementById("svg");
let tempLine = null, connections = [];

function portCenter(el){
  const r = el.getBoundingClientRect(), c = svg.getBoundingClientRect();
  return {x:r.left-c.left+r.width/2, y:r.top-c.top+r.height/2};
}
function makePath(a,b){ return `M${a.x},${a.y} C${a.x+40},${a.y} ${b.x-40},${b.y} ${b.x},${b.y}`; }

document.querySelectorAll(".port.out").forEach(out=>{
  out.onpointerdown = e=>{
    tempLine = document.createElementNS("http://www.w3.org/2000/svg","path");
    tempLine.setAttribute("stroke","#1f6feb"); tempLine.setAttribute("fill","none");
    tempLine.setAttribute("stroke-width","3"); svg.appendChild(tempLine);
    const start = portCenter(out);
    const move = ev=>{
      const end = {x:ev.clientX, y:ev.clientY};
      tempLine.setAttribute("d", makePath(start,end));
    };
    const up = ev=>{
      document.removeEventListener("pointermove",move);
      document.removeEventListener("pointerup",up);
      const el = document.elementFromPoint(ev.clientX,ev.clientY);
      if(el && el.classList.contains("in")){
        connections.push({from:out.closest(".node").id,to:el.closest(".node").id,
                          fromPort:out.dataset.port,toPort:el.dataset.port,line:tempLine});
        update();
      }else svg.removeChild(tempLine);
      tempLine=null;
    };
    document.addEventListener("pointermove",move);
    document.addEventListener("pointerup",up);
  };
});

function update(){
  // 1. 計算
  let vals = {
    num1: +document.getElementById("val1").value,
    num2: +document.getElementById("val2").value
  };
  let op = document.getElementById("op").value;
  let a = vals.num1, b = vals.num2, f;
  switch(op){case"+":f=a+b;break;case"-":f=a-b;break;case"*":f=a*b;break;case"/":f=b? a/b:"∞";}
  document.getElementById("result").textContent = f;

  // 2. 線を再描画
  connections.forEach(c=>{
    const p1 = portCenter(nodes(c.from,c.fromPort)), p2 = portCenter(nodes(c.to,c.toPort));
    c.line.setAttribute("d", makePath(p1,p2));
  });
}

function nodes(id,port){ return document.querySelector(`#${id} [data-port="${port}"]`); }

document.querySelectorAll("input,select").forEach(el=>el.addEventListener("input",update));
update();
</script>
</body>
</html>